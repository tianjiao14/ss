<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ä¸“ä¸šæ¯”èµ›å¯¹é˜µç”Ÿæˆå™¨ (æ™ºèƒ½è¿çº¿ç‰ˆ)</title>
    <style>
        :root {
            --primary-color: #27ae60; /* ä¸»è‰²ï¼šç»¿ */
            --placement-color: #f39c12; /* æ’ä½èµ›ï¼šæ©™ */
            --bg-color: #f5f7fa;
            --card-bg: #ffffff;
            --text-main: #303133;
            --border-color: #dcdfe6;
            --header-dark: #2c3e50;
            --line-color: #27ae60; /* è¿çº¿é¢œè‰² */
            --line-thickness: 2px; /* è¿çº¿ç²—ç»† */
        }

        body { font-family: "Helvetica Neue", Helvetica, "PingFang SC", "Microsoft YaHei", Arial, sans-serif; background-color: var(--bg-color); color: var(--text-main); margin: 0; padding: 0; }
        
        /* --- å¸ƒå±€å®¹å™¨ --- */
        #tab-bar-container { background-color: var(--header-dark); padding: 10px 20px 0 20px; display: flex; align-items: flex-end; gap: 5px; overflow-x: auto; }
        .tab { padding: 8px 20px; background-color: rgba(255,255,255,0.1); color: #ccc; border-radius: 6px 6px 0 0; cursor: pointer; display: flex; align-items: center; gap: 10px; font-size: 13px; border: 1px solid transparent; border-bottom: none; user-select: none; white-space: nowrap; }
        .tab.active { background-color: var(--bg-color); color: var(--primary-color); font-weight: bold; }
        .tab-add { color: #fff; font-size: 20px; padding: 0 15px; cursor: pointer; opacity: 0.7; }
        
        .main-wrapper { padding: 40px 20px; max-width: 1200px; margin: 0 auto; }
        .container { background-color: var(--card-bg); padding: 40px; border-radius: 8px; box-shadow: 0 4px 16px rgba(0,0,0,0.08); margin-bottom: 30px; }
        .section-title { font-size: 22px; font-weight: 600; padding-left: 15px; border-left: 5px solid var(--primary-color); margin-bottom: 30px; }

        /* --- è¡¨å• --- */
        .form-group { margin-bottom: 25px; }
        .form-row { display: flex; gap: 20px; }
        .form-col { flex: 1; }
        label { display: block; font-weight: 500; margin-bottom: 10px; }
        input, select, textarea { width: 100%; padding: 12px; border: 1px solid var(--border-color); border-radius: 4px; box-sizing: border-box; }
        
        /* --- æŒ‰é’® --- */
        .button-group { display: flex; gap: 15px; margin-top: 20px; flex-wrap: wrap; }
        button { padding: 12px 24px; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; font-weight: 600; color: white; transition: opacity 0.2s; }
        button:hover { opacity: 0.9; }
        .main-button { background-color: var(--primary-color); }
        .secondary-button { background-color: #909399; }
        
        /* --- åå•å½•å…¥ --- */
        .name-input-toggle { margin-bottom: 25px; display: flex; }
        .name-input-toggle button { background: #fff; color: #666; border: 1px solid var(--border-color); color: var(--text-main); border-radius: 0; }
        .name-input-toggle button:first-child { border-radius: 4px 0 0 4px; }
        .name-input-toggle button:last-child { border-radius: 0 4px 4px 0; }
        .name-input-toggle button.active { background-color: var(--primary-color); color: white; border-color: var(--primary-color); }
        .name-input-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 15px; }

        /* --- å¾ªç¯èµ›è¡¨æ ¼ (ä¿æŒåŸæ ·) --- */
        .data-table { border-collapse: collapse; width: 100%; margin-top: 15px; font-size: 14px; }
        .data-table th, .data-table td { border: 1px solid #ccc; padding: 8px; text-align: center; }
        .data-table th { background-color: #f5f7fa; font-weight: bold; }
        .crosstable .player-header { background-color: #f9f9f9; text-align: left; padding-left: 10px; font-weight: bold;}
        .crosstable .diagonal { background: linear-gradient(to top right, transparent calc(50% - 1px), #ccc, transparent calc(50% + 1px)); background-color: #f2f2f2; }
        .schedule-table th { background-color: #2c3e50; color: white; }

        /* --- æ·˜æ±°èµ›å¯¹é˜µå›¾ (æ»šåŠ¨ + è¿çº¿ä¿®å¤) --- */
        .result-title { text-align: center; color: var(--primary-color); margin-bottom: 30px; border-bottom: 1px solid #eee; padding-bottom: 15px; }
        
        .bracket-wrapper { 
            display: flex; 
            overflow-x: auto; 
            padding: 20px 0; 
            width: 100%; 
            justify-content: flex-start; 
        }
        
        .bracket { 
            display: flex; 
            padding-right: 60px; 
            position: relative;
            margin: 0 auto;
        }
        
        /* æ¯ä¸€è½®çš„åˆ— */
        .round { 
            display: flex; flex-direction: column; justify-content: space-around; 
            margin-right: 100px; /* åˆ—é—´è· */
            min-width: 100px;
            flex-shrink: 0;
            position: relative;
        }

        .match { 
            display: flex; flex-direction: column; justify-content: center; 
            position: relative; 
            margin: 15px 0;
        }

        /* å‚èµ›è€…å¡ç‰‡ */
        .participant {
            background: #fff; border: 1px solid var(--border-color); border-radius: 4px;
            padding: 0 4px; margin-bottom: 0; font-size: 14px; position: relative; z-index: 2;
            height: 36px; line-height: 36px; 
            box-shadow: 0 2px 4px rgba(0,0,0,0.05); cursor: pointer; user-select: none;
            overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
        }
        /* ä¸Šæ–¹é€‰æ‰‹æœ‰ä¸‹è¾¹è· */
        .participant[data-slot="top"] { margin-bottom: 10px; }
        
        .participant:hover { border-color: var(--primary-color); background-color: #f0f9eb; }
        .participant.winner { background-color: var(--primary-color); color: white; border-color: var(--primary-color); }
        .participant.loser { color: #aaa; text-decoration: line-through; background-color: #f9f9f9; }
        .participant.unplayed { color: #888; }

        /* --- æ™ºèƒ½è¿çº¿æ ·å¼ --- */
        /* æˆ‘ä»¬å°†ä½¿ç”¨ JS è®¡ç®—é«˜åº¦ï¼Œè¿™é‡Œåªå®šä¹‰åŸºç¡€æ ·å¼ */
        .connector-line {
            position: absolute;
            z-index: 1;
            border-color: var(--line-color);
            border-style: solid;
            border-width: 0;
            pointer-events: none;
        }

        /* ä¸Šä½æ¯”èµ›è¿çº¿ï¼šä»å³ä¾§ä¸­é—´å‡ºå‘ï¼Œå‘å³ï¼Œç„¶åå‘ä¸‹ (â” å½¢çŠ¶) */
        .connector-top {
            right: -70px; /* å‘å³å»¶ä¼¸è·ç¦» */
            width: 70px; 
            top: 50%; /* èµ·ç‚¹ï¼šæ¯”èµ›å—çš„å‚ç›´ä¸­å¿ƒ */
            /* height ç”± JS åŠ¨æ€è®¾ç½® */
            border-top-width: var(--line-thickness);
            border-right-width: var(--line-thickness);
            border-top-right-radius: 8px; /* åœ†è§’ */
        }

        /* ä¸‹ä½æ¯”èµ›è¿çº¿ï¼šä»å³ä¾§ä¸­é—´å‡ºå‘ï¼Œå‘å³ï¼Œç„¶åå‘ä¸Š (â”˜ å½¢çŠ¶) */
        .connector-bottom {
            right: -70px;
            width: 70px;
            bottom: 50%; /* èµ·ç‚¹ï¼šæ¯”èµ›å—çš„å‚ç›´ä¸­å¿ƒ */
            /* height ç”± JS åŠ¨æ€è®¾ç½® */
            border-bottom-width: var(--line-thickness);
            border-right-width: var(--line-thickness);
            border-bottom-right-radius: 8px; /* åœ†è§’ */
        }

        /* æŒ‡å‘ä¸‹ä¸€è½®çš„æ°´å¹³çº¿ (- å½¢çŠ¶) */
        /* åŠ åœ¨ Top connector ä¸Šï¼Œä½äºå…¶åº•éƒ¨å‘å³å»¶ä¼¸ */
        .connector-top::after {
            content: '';
            position: absolute;
            bottom: -1px; /* å¯¹é½åº•éƒ¨ */
            right: -20px; /* å‘å³å»¶ä¼¸åˆ°ä¸‹ä¸€è½®å·¦ä¾§ */
            width: 20px; 
            height: var(--line-thickness);
            background-color: var(--line-color);
        }

        /* --- æ’ä½èµ› --- */
        .placement-section-title { 
            color: var(--placement-color); text-align: center; 
            font-size: 1.2em; font-weight: bold; margin: 50px 0 25px 0; 
        }
        .placement-header-small {
            color: var(--placement-color); text-align: center; font-size: 1em;
            margin-bottom: 15px; font-weight: bold;
        }
        
        .bronze-container { display: flex; justify-content: center; }
        .bronze-match { width: 100px; }
        
        .placement-5-8-grid {
            display: flex; justify-content: center; gap: 80px; margin-top: 20px; flex-wrap: wrap;
        }
        .placement-col {
            display: flex; flex-direction: column; justify-content: center; gap: 40px;
        }

        .participant.placement {
            border: 1px solid var(--placement-color); text-align: center;
            color: #555; margin-bottom: 0; margin-top: 10px;
        }
        .participant.placement:first-child { margin-top: 0; }
        .participant.placement:hover { background-color: #fffaf0; }
        
        .participant.placement.winner {
            background-color: var(--placement-color); color: white; border-color: var(--placement-color);
        }
        .participant.placement.loser { background-color: #fdfdfd; text-decoration: none; opacity: 0.6; }

        /* --- æœ€ç»ˆåæ¬¡ --- */
        #final-standings-container { text-align: center; }
        .standings-list { 
            list-style: none; padding: 0; display: inline-block; text-align: left; min-width: 250px;
        }
        .standings-list li { 
            padding: 12px 20px; border-bottom: 1px dashed #ddd; font-size: 16px;
            display: flex; justify-content: space-between;
        }
        .standings-list strong { color: var(--primary-color); font-weight: bold; }

/* --- æ‰“å°/å¯¼å‡ºPDF ä¸“ç”¨ä¼˜åŒ–æ ·å¼ (æœ€ç»ˆç‰ˆ) --- */
@media print {
    /* 1. åŸºç¡€è®¾ç½® */
    @page {
        margin: 5mm;
    }

    body { 
        background: white; 
        -webkit-print-color-adjust: exact; 
        print-color-adjust: exact;
        font-size: 12pt;
        margin: 0;
        padding: 0;
        width: 100%;
    }

    /* 2. éšè—æ— å…³å…ƒç´  */
    #tab-bar-container, 
    #setup-container, 
    #name-entry-container, 
    #controls-container,
    #advance-controls,
    .button-group, .tab-add, .name-input-toggle {
        display: none !important;
    }

    #results { display: block !important; width: 100%;margin: 0;padding: 0; }

    .container { 
        box-shadow: none !important; 
        border: none !important; 
        padding: 0 !important; 
        margin: 0 !important; 
        width: 100% !important; 
        max-width: none !important; 
    }

    /* --- æ ¸å¿ƒåˆ†é¡µæ§åˆ¶ --- */

    /* A. æ··åˆèµ›ç¬¬äºŒé˜¶æ®µï¼šå¼ºåˆ¶æ¢é¡µ (ä¿ç•™ä½ ä¹‹å‰çš„éœ€æ±‚) */
    #knockout-stage-wrapper {
        page-break-before: always !important; 
        break-before: page !important;
        width: 100% !important;
        padding-top: 20px;
        display: block !important;
    }

    /* B. å¯¹é˜µæ ‘çŠ¶å›¾ï¼šç¦æ­¢å†…éƒ¨æ–­è£‚ */
   .bracket-wrapper { 
        page-break-inside: avoid !important;
        break-inside: avoid !important;
        display: block !important;
        width: 100% !important;
        overflow: visible !important;
        margin-bottom: 20px;
    }
    .bracket { 
        display: flex !important;
        flex-wrap: nowrap !important;
        justify-content: center;
        margin: 0 auto !important;
        zoom: 0.85; /* é€‚å½“ç¼©å°ä»¥å®¹çº³æ›´å¤šå±‚çº§ */
    }
    /* C. æ’ä½èµ›ç‹¬ç«‹æ¨¡å— (3-4å, 5-8å) */
    /* å…³é”®ï¼šæ¯ä¸ªæ¨¡å—ä½œä¸ºä¸€ä¸ªæ•´ä½“ï¼Œç¦æ­¢å†…éƒ¨åˆ‡å¼€ */
    /* æµè§ˆå™¨ä¼šè‡ªåŠ¨è®¡ç®—ï¼šå¦‚æœç©ºé—´å¤Ÿå°±æ”¾è¿™é¡µï¼Œä¸å¤Ÿå°±ç”©åˆ°ä¸‹ä¸€é¡µ */
    .placement-block {
        page-break-inside: avoid !important;
        break-inside: avoid !important;
        display: block !important;
        margin-top: 20px;
    }

    /* D. å¾ªç¯èµ›å°ç»„ï¼šç¦æ­¢å†…éƒ¨æ–­å¼€ */
    .group-container {
        page-break-inside: avoid !important;
        break-inside: avoid !important;
        margin-bottom: 20px;
    }

    /* E. æœ€ç»ˆåæ¬¡ï¼šå¼ºåˆ¶å¦èµ·ä¸€é¡µ */
    #final-standings-container {
        page-break-before: always !important; 
        break-before: page !important;
        padding-top: 30px;
    }

    /* è¾…åŠ©æ ·å¼ */
    .match { page-break-inside: avoid; }
    .connector-line, .connector-line::after {
        border-color: #000 !important;
        
    }
    .result-title {
        color: #000 !important;
        border-bottom: 2px solid #000 !important;
    }
}
/* --- æ–°å¢ï¼šæ¯”åˆ†ç›¸å…³æ ·å¼ --- */
/* å…è®¸æ¯”åˆ†æ˜¾ç¤ºåœ¨ç›’å­å¤–éƒ¨ */
.match { overflow: visible !important; } 
.score-inputs {
    position: absolute;
    /* è¿™é‡Œçš„ bottom: 50% æ„å‘³ç€å®¹å™¨çš„åº•éƒ¨æ­£å¥½è´´åœ¨æ¯”èµ›å—çš„å‚ç›´ä¸­å¿ƒçº¿ä¸Š */
    top: auto;
    bottom: 50%; 
    right: -75px;   /* æ ¹æ®çº¿é•¿å¾®è°ƒ */
    
    /* å®¹å™¨æ ·å¼ */
    width: 60px;
    height: 20px;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 2px;
    z-index: 20;
    
    /* åŠ ä¸€ç‚¹ä¸‹è¾¹è·ï¼Œè®©å®ƒä¸è¦æ­»æ­»å‹åœ¨çº¿ä¸Šï¼Œç•™ç‚¹å‘¼å¸æ„Ÿ */
    margin-bottom: 2px;
}

/* 2. ç‰¹æ®Šæƒ…å†µ (å¥‡æ•°åœº/ä¸‹ä½)ï¼šæ˜¾ç¤ºåœ¨æ¨ªçº¿ã€ä¸‹æ–¹ã€‘ */
/* åªè¦æœ‰ lower-match æ ‡è®°ï¼Œå°±æ‰§è¡Œè¿™é‡Œçš„æ ·å¼ */
.lower-match .score-inputs {
    /* è¿™é‡Œçš„ top: 50% æ„å‘³ç€å®¹å™¨çš„é¡¶éƒ¨æ­£å¥½è´´åœ¨æ¯”èµ›å—çš„å‚ç›´ä¸­å¿ƒçº¿ä¸Š */
    top: 50%;
    bottom: auto;
    
    /* åŠ ä¸€ç‚¹ä¸Šè¾¹è·ï¼ŒåŒç† */
    margin-top: 2px;
    margin-bottom: 0;
}

/* å•ä¸ªè¾“å…¥æ¡†æ ·å¼ (ä¸å˜) */
.score-input {
    width: 24px !important;
    height: 20px;
    padding: 0 !important;
    text-align: center;
    font-size: 12px;
    font-weight: bold;
    border: 1px solid #27ae60;
    background: #fff;
    border-radius: 2px;
    margin: 0 !important;
}

/* æ¸…é™¤å¹²æ‰° (ä¸å˜) */
.s-top, .s-bottom {
    position: static !important;
}
.final-score { 
    position: absolute; 
    right: -60px; /* ä¸è¾“å…¥æ¡†ä½ç½®ä¸€è‡´ */
    top: 50%;
    transform: translateY(-50%);
    background-color: #fff;
    padding: 2px 5px;
    border-radius: 4px;
    border: 1px solid var(--primary-color);
    /* ...å…¶ä»–ä¿æŒä¸å˜ */
}
    </style>
</head>
<body>

<div id="tab-bar-container">
    <div class="tab-add" id="new-tab-btn" title="æ–°å»ºæ¯”èµ›">+</div>
</div>

<div class="main-wrapper">

    <div class="container" id="setup-container">
        <h1 class="section-title">ç¬¬ä¸€æ­¥ï¼šèµ›äº‹è®¾ç½®</h1>
        <form id="setup-form">
            <div class="form-group"><label>é¡¹ç›®åç§°</label><input type="text" id="sport-name" value="æ–°æ¯”èµ›" required></div>
            <div class="form-row">
                <div class="form-col"><label>å‚èµ›äººæ•°</label><input type="number" id="num-participants" value="8" min="2" required></div>
                <div class="form-col">
                    <label>èµ›åˆ¶é€‰æ‹©</label>
                    <select id="tournament-type">
                        <option value="knockout">å•è´¥æ·˜æ±°èµ›</option>
                        <option value="round-robin">å¾ªç¯èµ›</option>
                        <option value="mixed">æ··åˆèµ›åˆ¶</option>
                    </select>
                </div>
            </div>
            <div class="button-group">
                <button type="submit" class="main-button">ä¸‹ä¸€æ­¥ï¼šå½•å…¥åå•</button>
                <button type="button" id="import-btn" class="secondary-button">å¯¼å…¥æ—§æ•°æ®</button>
            </div>
        </form>
    </div>

    <div class="container" id="name-entry-container" style="display:none;">
        <h2 class="section-title">ç¬¬äºŒæ­¥ï¼šé€‰æ‰‹å½•å…¥</h2>
        <div class="name-input-toggle">
            <button id="toggle-manual" class="active">æ‰‹åŠ¨è¾“å…¥</button>
            <button id="toggle-batch">æ‰¹é‡ç²˜è´´</button>
        </div>
        <div id="manual-inputs" class="name-input-grid"></div>
        <div id="batch-input" style="display:none;">
            <textarea id="participants-list" placeholder="åœ¨æ­¤ç²˜è´´åå•ï¼Œæ¯è¡Œä¸€ä¸ªåå­—&#10;å¼ ä¸‰(1) &#10;æå››" style="min-height: 200px; width:100%; border:1px solid #ccc; padding:10px;"></textarea>
        </div>
        <div class="button-group">
            <button id="back-to-setup" class="secondary-button">è¿”å›ä¸Šä¸€æ­¥</button>
            <button id="generate-btn" class="main-button">ç”Ÿæˆå¯¹é˜µè¡¨</button>
        </div>
    </div>

    <div id="results"></div>

    <div class="container" id="controls-container" style="display:none;">
        <div class="button-group">
            <button id="save-btn" class="main-button">ä¿å­˜å½“å‰è¿›åº¦</button>
            <button id="print-btn" class="secondary-button">æ‰“å° / å¯¼å‡ºPDF</button>
            <button id="edit-btn" class="secondary-button">ä¿®æ”¹è®¾ç½®</button>
            <button id="export-json-btn" class="secondary-button">å¤‡ä»½æ•°æ® (.json)</button>
        </div>
    </div>

</div>

<input type="file" id="file-input" style="display:none" accept=".json">

<script>
document.addEventListener('DOMContentLoaded', function() {
    let allTournaments = {};
    let activeId = null;

    const ui = {
        tabs: document.getElementById('tab-bar-container'),
        setup: document.getElementById('setup-container'),
        names: document.getElementById('name-entry-container'),
        results: document.getElementById('results'),
        controls: document.getElementById('controls-container'),
        manualInputs: document.getElementById('manual-inputs'),
        batchInput: document.getElementById('batch-input'),
        fileInput: document.getElementById('file-input')
    };

    function init() {
        try {
            const data = localStorage.getItem('my_tournament_data_v13');
            if (data) allTournaments = JSON.parse(data);
        } catch (e) { console.error("è¯»å–å­˜æ¡£å¤±è´¥", e); }
        
        renderTabs();
        const ids = Object.keys(allTournaments);
        if (ids.length > 0) setActive(ids[ids.length - 1]);
        else showSetup();

        document.getElementById('new-tab-btn').onclick = createNewTab;
        document.getElementById('setup-form').onsubmit = (e) => { e.preventDefault(); toNameEntry(); };
        document.getElementById('toggle-manual').onclick = () => toggleInputMode(true);
        document.getElementById('toggle-batch').onclick = () => toggleInputMode(false);
        document.getElementById('back-to-setup').onclick = showSetup;
        document.getElementById('generate-btn').onclick = generateTournament;
        document.getElementById('save-btn').onclick = () => saveData(true);
        document.getElementById('print-btn').onclick = () => window.print();
        document.getElementById('edit-btn').onclick = editCurrent;
        document.getElementById('export-json-btn').onclick = exportJson;
        document.getElementById('import-btn').onclick = () => ui.fileInput.click();
        
        ui.fileInput.onchange = importJson;
        ui.results.addEventListener('click', handleMatchClick);
        ui.results.addEventListener('input', handleTableInput);
        ui.results.addEventListener('focusout', handleTableBlur);
        window.addEventListener('resize', () => {
             if (document.querySelector('.bracket')) {
                 drawConnectors();
             }
        });
    }
function handleTableInput(e) {
    const cell = e.target;
    if (cell.tagName !== 'TD' || !cell.isContentEditable || !cell.closest('.crosstable')) return;

    const row = cell.parentElement;
    const table = row.parentElement.parentElement;
    const rowIndex = row.rowIndex; 
    const colIndex = cell.cellIndex; 

    const totalCols = table.rows[0].cells.length;
    if (colIndex > totalCols - 4) return; 
    
    const val = cell.innerText.trim();

    const match = val.match(/^(\d+)\s*([:ï¼š\-\s])\s*(\d+)([\s\S]*)$/);
    
    if (match) {
        const s1 = match[1]; // å·¦åˆ†
        const sep = match[2]; 
        const s2 = match[3]; // å³åˆ†
        const details = match[4].trim(); // å°åˆ†è¯¦æƒ…

        const mirrorS1 = s2;
        const mirrorS2 = s1;
        
        let mirrorDetails = "";
        if (details) {
            mirrorDetails = details.replace(/(\d+)\s*([:ï¼š\-\s])\s*(\d+)/g, "$3$2$1");
        }
        let html = `<strong>${mirrorS1}${sep}${mirrorS2}</strong>`;
        if (mirrorDetails) {
            html += `<br><span style="font-size:12px; color:#888; display:block; line-height:1.2;">${mirrorDetails}</span>`;
        }
        
        if (table.rows[colIndex] && table.rows[colIndex].cells[rowIndex]) {
            const mirrorCell = table.rows[colIndex].cells[rowIndex];
            // ä½¿ç”¨ innerHTML å†™å…¥ HTML æ ‡ç­¾
            if (mirrorCell.innerHTML !== html) {
                mirrorCell.innerHTML = html;
            }
        }
    } else if (val === "") {
   
         if (table.rows[colIndex] && table.rows[colIndex].cells[rowIndex]) {
            const mirrorCell = table.rows[colIndex].cells[rowIndex];
            if (mirrorCell.innerText !== "") mirrorCell.innerHTML = "";
        }
    }
}
function handleTableBlur(e) {
    const cell = e.target;
    if (cell.tagName !== 'TD' || !cell.isContentEditable || !cell.closest('.crosstable')) return;
    const val = cell.innerText.trim();
    const match = val.match(/^(\d+)\s*([:ï¼š\-\s])\s*(\d+)([\s\S]*)$/);

    if (match) {
        const s1 = match[1];
        const sep = match[2];
        const s2 = match[3];
        const details = match[4].trim(); // æå–æ‹¬å·é‡Œçš„å†…å®¹

        let html = `<strong>${s1}${sep}${s2}</strong>`;
        if (details) {
            html += `<br><span style="font-size:12px; color:#888; display:block; line-height:1.2;">${details}</span>`;
        }
       
        cell.innerHTML = html;
    }
}
    function hideAll() {
        ui.setup.style.display = 'none';
        ui.names.style.display = 'none';
        ui.results.style.display = 'none';
        ui.controls.style.display = 'none';
    }

    function showSetup() {
        hideAll();
        activeId = null;
        renderTabs();
        ui.setup.style.display = 'block';
        document.getElementById('sport-name').value = "æ–°æ¯”èµ›";
    }

    function toNameEntry() {
        hideAll();
        ui.names.style.display = 'block';
        const count = parseInt(document.getElementById('num-participants').value);
        renderNameInputs(count);
    }

    function renderNameInputs(n) {
        ui.manualInputs.innerHTML = '';
        for (let i = 0; i < n; i++) {
            ui.manualInputs.innerHTML += `<input type="text" placeholder="é€‰æ‰‹ ${i + 1}">`;
        }
    }

    function toggleInputMode(isManual) {
        ui.manualInputs.style.display = isManual ? 'grid' : 'none';
        ui.batchInput.style.display = isManual ? 'none' : 'block';
        document.getElementById('toggle-manual').className = isManual ? 'active' : '';
        document.getElementById('toggle-batch').className = !isManual ? 'active' : '';
    }

    function createNewTab() { showSetup(); }

    function generateTournament() {
    const sportName = document.getElementById('sport-name').value;
    const count = parseInt(document.getElementById('num-participants').value);
    const type = document.getElementById('tournament-type').value;
    
    let players = [];
    if (ui.manualInputs.style.display !== 'none') {
        ui.manualInputs.querySelectorAll('input').forEach(inp => {
            players.push(inp.value.trim() || inp.placeholder);
        });
    } else {
        const txt = document.getElementById('participants-list').value;
        players = txt.split('\n').map(x => x.trim()).filter(x => x);
        while(players.length < count) players.push(`é€‰æ‰‹ ${players.length + 1}`);
    }

    createTournamentObj(sportName, type, players, count, activeId);
}

   function createTournamentObj(name, type, players, count, existingId = null) {
    // å¦‚æœä¼ å…¥äº† existingIdï¼Œå°±ç”¨æ—§çš„ IDï¼ˆè¦†ç›–æ›´æ–°ï¼‰ï¼›å¦åˆ™ç”Ÿæˆæ–° ID
    const id = existingId || ('t_' + new Date().getTime());
    
    allTournaments[id] = {
        id: id,
        sportName: name,
        type: type, 
        players: players,
        count: count,
        html: ''
    };

    activeId = id; // ç¡®ä¿å½“å‰æ¿€æ´» ID æ­£ç¡®
    
    if (type === 'knockout') {
        const seeds = arrangePlayersWithSeeding(players);
        const bracketHtml = getBracketHTML(seeds, name);
        allTournaments[id].html = bracketHtml;
    } else {
        renderGroupStage(players, name, type === 'mixed');
    }
    setActive(id);
    saveData(false);
 
    renderTabs(); 
}
    function setActive(id) {
        if (!allTournaments[id]) return showSetup();
        activeId = id;
        hideAll();
        renderTabs();
        const t = allTournaments[id];
        ui.results.innerHTML = t.html;
        ui.results.style.display = 'block';
        ui.controls.style.display = 'block';
        
        setTimeout(() => {
            if (document.querySelector('.bracket')) {
                drawConnectors();
                autoAdvanceByes();
            }
        }, 50);

        if (t.type === 'mixed') {
            const advanceBtn = document.getElementById('advance-btn');
            if(advanceBtn) advanceBtn.onclick = advanceMixedToKnockout;
        }
    }

    function renderTabs() {
        const existingTabs = ui.tabs.querySelectorAll('.tab');
        existingTabs.forEach(t => t.remove());

        Object.values(allTournaments).forEach(t => {
            const div = document.createElement('div');
            div.className = `tab ${t.id === activeId ? 'active' : ''}`;
            
            const titleSpan = document.createElement('span');
            titleSpan.textContent = t.sportName;
            div.appendChild(titleSpan);

            const closeSpan = document.createElement('span');
            closeSpan.textContent = 'Ã—';
            closeSpan.style.marginLeft = '10px';
            closeSpan.style.opacity = '0.6';
            closeSpan.style.cursor = 'pointer';
            
            closeSpan.onmouseover = () => { closeSpan.style.opacity = '1'; closeSpan.style.color = '#e74c3c'; };
            closeSpan.onmouseout = () => { closeSpan.style.opacity = '0.6'; closeSpan.style.color = 'inherit'; };

            closeSpan.onclick = (e) => {
                e.stopPropagation(); 
                deleteTournament(t.id);
            };

            div.appendChild(closeSpan);
            
            div.onclick = () => {
                if (activeId !== t.id) setActive(t.id);
            };

            ui.tabs.insertBefore(div, document.getElementById('new-tab-btn'));
        });
    }

    function deleteTournament(id) {
        const t = allTournaments[id];
        if (!t) return;
        if (confirm(`ç¡®å®šè¦å½»åº•åˆ é™¤ "${t.sportName}" å—ï¼Ÿ`)) {
            delete allTournaments[id];
            if (activeId === id) {
                const remainingIds = Object.keys(allTournaments);
                if (remainingIds.length > 0) {
                    setActive(remainingIds[remainingIds.length - 1]);
                } else {
                    activeId = null;
                    showSetup();
                }
            }
            saveData(false);
            renderTabs();
        }
    }

    function distributeByes(n, k, dir) {
        if (k === 0) return new Array(n).fill(false);
        if (k === n) return new Array(n).fill(true);
        if (n === 2) {
            if (k === 1) {
                if (dir === 'top_down') return [false, true];
                else return [true, false];
            }
        }
        const half = n / 2;
        let topK, bottomK;
        if (k % 2 === 0) {
            topK = k / 2; bottomK = k / 2;
        } else {
            if (dir === 'top_down') { topK = Math.ceil(k / 2); bottomK = Math.floor(k / 2); } 
            else { topK = Math.floor(k / 2); bottomK = Math.ceil(k / 2); }
        }
        return [...distributeByes(half, topK, dir), ...distributeByes(half, bottomK, dir)];
    }

    function getStandardSeedOrder(numSlots) {
        let order = [1, 2];
        while (order.length < numSlots) {
            const nextOrder = [];
            const nextN = order.length * 2 + 1;
            for (let i = 0; i < order.length; i++) {
                const val = order[i];
                const complement = nextN - val;
                if (i % 2 === 0) { nextOrder.push(val); nextOrder.push(complement); }
                else { nextOrder.push(complement); nextOrder.push(val); }
            }
            order = nextOrder;
        }
        return order.map(r => r - 1);
    }

    function arrangePlayersWithSeeding(names) {
        let n = names.length;
        let total = Math.pow(2, Math.ceil(Math.log2(n))); 
        let numByes = total - n;

        let topByesCount, bottomByesCount;
        if (numByes % 2 === 0) { topByesCount = numByes / 2; bottomByesCount = numByes / 2; } 
        else { bottomByesCount = Math.ceil(numByes / 2); topByesCount = numByes - bottomByesCount; }

        let topMap = distributeByes(total / 2, topByesCount, 'top_down');
        let bottomMap = distributeByes(total / 2, bottomByesCount, 'bottom_up');
        let isBye = [...topMap, ...bottomMap];

        let finalBracket = new Array(total).fill(null);
        for (let i = 0; i < total; i++) { if (isBye[i]) finalBracket[i] = "è½®ç©º"; }

        let seeds = [], others = [];
        names.forEach(p => {
            const m = p.match(/[\(ï¼ˆ](\d+)[\)ï¼‰]/);
            if(m) seeds.push({ name: p, rank: parseInt(m[1]) });
            else others.push(p);
        });
        seeds.sort((a, b) => a.rank - b.rank);
        others.sort(() => 0.5 - Math.random());

        let seedSlots = getStandardSeedOrder(total);
        seeds.forEach(s => {
            let placed = false;
            for (let i = 0; i < seedSlots.length; i++) {
                let slotIdx = seedSlots[i];
                if (finalBracket[slotIdx] === null) {
                    finalBracket[slotIdx] = s.name;
                    seedSlots[i] = -1;
                    placed = true;
                    break;
                }
            }
            if (!placed) others.push(s.name);
        });

        for (let i = 0; i < total; i++) {
            if (finalBracket[i] === null) {
                if (others.length > 0) finalBracket[i] = others.shift();
                else finalBracket[i] = "å¾…å®š";
            }
        }
        return finalBracket;
    }

/* --- æ›¿æ¢ getBracketHTML å‡½æ•° --- */

function getBracketHTML(playerList, title) {
    let html = `<div class="container bracket-container" style="border-top: 5px solid var(--header-dark); margin-top:50px;">
                <h2 class="result-title" style="margin-top:20px;">${title}</h2>`;
    const n = playerList.length;
    const rounds = Math.ceil(Math.log2(n));
    const slots = Math.pow(2, rounds);
    
    html += `<div class="bracket-wrapper"><div class="bracket">`;

    for (let r = 0; r < rounds; r++) {
        html += `<div class="round" data-round="${r}">`;
        const matchesCount = slots / Math.pow(2, r + 1);
        
        for (let m = 0; m < matchesCount; m++) {
            let p1 = "å¾…å®š", p2 = "å¾…å®š";
            let c1 = "participant unplayed", c2 = "participant unplayed";
            
            if (r === 0) {
                p1 = playerList[m * 2] || "è½®ç©º";
                p2 = playerList[m * 2 + 1] || "è½®ç©º";
                if (p1 !== "è½®ç©º") c1 = "participant";
                if (p2 !== "è½®ç©º") c2 = "participant";
            }

            const isLower = (m % 2 !== 0); 
            const lowerClass = isLower ? "lower-match" : ""; 

            let scoreHtml = `
            <div class="score-inputs">
                <input type="text" class="score-input s-top" value="">
                <input type="text" class="score-input s-bottom" value="">
            </div>`;

            const matchUniqueId = `r${r}-m${m}`;
            html += `
            <div class="match ${lowerClass}" id="${matchUniqueId}" data-mid="${m}">
                <div class="${c1}" data-slot="top">${p1}</div>
                ${scoreHtml}  
                <div class="${c2}" data-slot="bottom">${p2}</div>
            </div>`;
        }
        html += `</div>`;
    }
    html += `</div></div>`; 

    // --- æ ¸å¿ƒä¿®æ”¹ï¼šç§»é™¤å¤§å®¹å™¨ï¼Œæ”¹ä¸ºç»™æ¯ä¸ªæ¨¡å—å•ç‹¬åŠ  "placement-block" åŒ…è£… ---

    if (n >= 4) {
        // 3-4å æ¨¡å—
        html += `<div class="placement-block">`;
        html += `
        <div class="placement-section-title">3-4åå†³èµ›</div>
        <div class="bronze-container">
            <div class="match bronze-match" data-type="bronze">
                <div class="participant placement unplayed" data-slot="top">åŠå†³èµ›è´Ÿè€…1</div>
                <div class="score-inputs">
                    <input type="text" class="score-input s-top" placeholder="">
                    <input type="text" class="score-input s-bottom" placeholder="">
                </div>
                <div class="participant placement unplayed" data-slot="bottom">åŠå†³èµ›è´Ÿè€…2</div>
            </div>
        </div>`;
        html += `</div>`; // block end
    }
    
    if (n >= 8) {
        // 5-8å æ¨¡å—
        html += `<div class="placement-block">`;
        html += `<div class="placement-section-title">5-8åæ’åèµ›</div>
        <div class="placement-5-8-grid">
            <div class="placement-col">
                <div class="placement-header-small">æ’ä½èµ›ç¬¬ä¸€è½®</div>
                <div class="match bronze-match" data-type="58_semi_1">
                    <div class="participant placement unplayed" data-slot="top">å…«å¼ºè´Ÿè€…</div>
                    <div class="score-inputs"><input type="text" class="score-input s-top"><input type="text" class="score-input s-bottom"></div>
                    <div class="participant placement unplayed" data-slot="bottom">å…«å¼ºè´Ÿè€…</div>
                </div>
                <div class="match bronze-match" data-type="58_semi_2">
                    <div class="participant placement unplayed" data-slot="top">å…«å¼ºè´Ÿè€…</div>
                    <div class="score-inputs"><input type="text" class="score-input s-top"><input type="text" class="score-input s-bottom"></div>
                    <div class="participant placement unplayed" data-slot="bottom">å…«å¼ºè´Ÿè€…</div>
                </div>
            </div>
            <div class="placement-col">
                <div>
                    <div class="placement-header-small">5-6åå†³èµ›</div>
                    <div class="match bronze-match" data-type="56_final">
                        <div class="participant placement unplayed" data-slot="top">èƒœè€…</div>
                        <div class="score-inputs"><input type="text" class="score-input s-top"><input type="text" class="score-input s-bottom"></div>
                        <div class="participant placement unplayed" data-slot="bottom">èƒœè€…</div>
                    </div>
                </div>
                <div style="margin-top:40px">
                    <div class="placement-header-small">7-8åå†³èµ›</div>
                    <div class="match bronze-match" data-type="78_final">
                        <div class="participant placement unplayed" data-slot="top">è´Ÿè€…</div>
                        <div class="score-inputs"><input type="text" class="score-input s-top"><input type="text" class="score-input s-bottom"></div>
                        <div class="participant placement unplayed" data-slot="bottom">è´Ÿè€…</div>
                    </div>
                </div>
            </div>
        </div>`;
        html += `</div>`; // block end
    }

    html += `<div id="final-standings-container" style="display:none; margin-top:40px;">
                <h2 class="result-title">ğŸ† æœ€ç»ˆåæ¬¡ ğŸ†</h2>
                <ul class="standings-list"></ul>
             </div>`;
    
    html += `</div>`;
    return html;
}

    function renderBracket(playerList, title) {
        const html = getBracketHTML(playerList, title);
        ui.results.innerHTML = html;
        if(allTournaments[activeId]) allTournaments[activeId].html = html;
        setTimeout(() => {
            drawConnectors();
            autoAdvanceByes();
        }, 50);
    }
    
    function drawConnectors() {
        document.querySelectorAll('.connector-line').forEach(el => el.remove());
        const bracket = document.querySelector('.bracket');
        if (!bracket) return;
        const rounds = bracket.querySelectorAll('.round');
        for (let r = 0; r < rounds.length - 1; r++) {
            const matches = rounds[r].querySelectorAll('.match');
            for (let i = 0; i < matches.length; i += 2) {
                const topMatch = matches[i];
                const bottomMatch = matches[i+1];
                const topRect = topMatch.getBoundingClientRect();
                const bottomRect = bottomMatch.getBoundingClientRect();
                
                const dist = bottomRect.top - topRect.top;
                const halfDist = dist / 2;
                
                const lineTop = document.createElement('div');
                lineTop.className = 'connector-line connector-top';
                lineTop.style.height = `${halfDist}px`;
                topMatch.appendChild(lineTop);
                
                const lineBottom = document.createElement('div');
                lineBottom.className = 'connector-line connector-bottom';
                lineBottom.style.height = `${halfDist}px`;
                bottomMatch.appendChild(lineBottom);
            }
        }
    }

/* --- æ›¿æ¢ handleMatchClick å‡½æ•° --- */

function handleMatchClick(e) {
    const p = e.target.closest('.participant');
    if (!p || p.classList.contains('unplayed') || p.textContent === "è½®ç©º") return;
    
    const match = p.parentElement;
    
    // æ’¤é”€é€»è¾‘
    if (match.classList.contains('decided')) {
        if(confirm("æ’¤é”€è¿™åœºæ¯”èµ›ç»“æœï¼Ÿ")) resetMatch(match);
        return;
    }

    const top = match.querySelector('[data-slot="top"]');
    const bottom = match.querySelector('[data-slot="bottom"]');
    const winner = p;
    const loser = (p === top) ? bottom : top;
    
    // 1. è¯»å–å¹¶æ˜¾ç¤ºæ¯”åˆ† (ä¿æŒä¸å˜)
    const inputs = match.querySelector('.score-inputs');
    let scoreText = '';
    if (inputs) {
        const sTop = inputs.querySelector('.s-top').value.trim();
        const sBottom = inputs.querySelector('.s-bottom').value.trim();
        if (sTop !== '' || sBottom !== '') {
            scoreText = `${sTop || 0} : ${sBottom || 0}`;
            inputs.style.display = 'none';
            const scoreDisplay = document.createElement('div');
            scoreDisplay.className = 'final-score';
            scoreDisplay.textContent = scoreText;
            match.appendChild(scoreDisplay);
        }
    }

    // 2. æ ‡è®°èƒœè´Ÿ
    match.classList.add('decided');
    winner.classList.add('winner');
    loser.classList.add('loser');

    // è·å–çº¯å‡€çš„åå­— (é˜²æ­¢å·²ç»æœ‰å›¾æ ‡äº†é‡å¤åŠ )
    const wName = winner.textContent.replace(/[ğŸ¥‡ğŸ¥ˆğŸ¥‰]/g, '').trim();
    const lName = loser.textContent.replace(/[ğŸ¥‡ğŸ¥ˆğŸ¥‰]/g, '').trim();

    // --- æ ¸å¿ƒä¿®æ”¹ï¼šç»™åå­—åŠ å¥–ç‰Œ ---
    const roundDiv = match.closest('.round');
    
    // A. åˆ¤æ–­æ˜¯å¦æ˜¯å†³èµ› (æœ€åä¸€è½®)
    // åªæœ‰åœ¨æ™®é€šæ·˜æ±°èµ›ä¸­æ‰æœ‰â€œroundâ€æ¦‚å¿µ
    if (roundDiv) {
        const allRounds = match.closest('.bracket').querySelectorAll('.round');
        // å¦‚æœå½“å‰æ˜¯æœ€åä¸€è½®
        if (parseInt(roundDiv.dataset.round) === allRounds.length - 1) {
            winner.textContent = 'ğŸ¥‡ ' + wName; // å† å†›åŠ é‡‘ç‰Œ
            loser.textContent = 'ğŸ¥ˆ ' + lName;  // äºšå†›åŠ é“¶ç‰Œ
        }
    }

    // B. åˆ¤æ–­æ˜¯å¦æ˜¯å­£å†›èµ› (é“œç‰Œèµ›)
    if (match.dataset.type === 'bronze') {
        winner.textContent = 'ğŸ¥‰ ' + wName; // å­£å†›åŠ é“œç‰Œ
    }
    // ----------------------------

    // 3. æ¨è¿›ä¸‹ä¸€è½®é€»è¾‘
    if (match.dataset.type) {
        handlePlacementAdvance(match.dataset.type, wName, lName);
    } else {
        const r = parseInt(roundDiv.dataset.round);
        const m = parseInt(match.dataset.mid);
        const nextR = roundDiv.nextElementSibling;
        
        if (nextR) {
            const nextM = Math.floor(m / 2);
            const nextSlot = (m % 2 === 0) ? 'top' : 'bottom';
            const target = nextR.querySelector(`.match[data-mid="${nextM}"] [data-slot="${nextSlot}"]`);
            if (target) {
                target.textContent = wName;
                target.classList.remove('unplayed');
            }
        }
        
        const allRounds = match.closest('.bracket').querySelectorAll('.round');
        const totalR = allRounds.length;
        // è¾“çš„äººè¿›å­£å†›èµ›
        if (r === totalR - 2) updateSlot('bronze', 'unplayed', lName);
        if (r === totalR - 3) updateSlot((m < 2) ? '58_semi_1' : '58_semi_2', 'unplayed', lName);
    }
    
    updateStandings();
    saveData(false);
}

    function handlePlacementAdvance(type, wName, lName) {
        if (type === '58_semi_1' || type === '58_semi_2') {
            updateSlot('56_final', 'unplayed', wName);
            updateSlot('78_final', 'unplayed', lName);
        }
    }

    function updateSlot(matchType, className, text) {
        const match = ui.results.querySelector(`.match[data-type="${matchType}"]`);
        if (!match) return;
        const slots = match.querySelectorAll('.participant');
        for (let s of slots) {
            if (s.classList.contains('unplayed') || s.textContent.includes('è´Ÿè€…') || s.textContent.includes('èƒœè€…')) {
                s.textContent = text;
                s.classList.remove('unplayed');
                break; 
            }
        }
    }

function resetMatch(match) {
    match.classList.remove('decided');
    match.querySelectorAll('.participant').forEach(p => {
        p.classList.remove('winner');
        p.classList.remove('loser');
        
        // --- æ ¸å¿ƒä¿®æ”¹ï¼šæ’¤é”€æ—¶æŠŠå¥–ç‰Œå›¾æ ‡åˆ æ‰ï¼Œæ¢å¤çº¯åå­— ---
        p.textContent = p.textContent.replace(/[ğŸ¥‡ğŸ¥ˆğŸ¥‰]/g, '').trim();
    });
    
    // ç§»é™¤æ¯”åˆ†æ˜¾ç¤º
    const scoreDisplay = match.querySelector('.final-score');
    if (scoreDisplay) scoreDisplay.remove();
    
    // æ¢å¤è¾“å…¥æ¡†
    const inputs = match.querySelector('.score-inputs');
    if (inputs) inputs.style.display = 'flex';
    
    saveData(false);
}

    function autoAdvanceByes() {
        const round0 = ui.results.querySelector('.round[data-round="0"]');
        if(!round0) return;
        
        setTimeout(() => {
            const matches = round0.querySelectorAll('.match');
            matches.forEach(m => {
                if (m.classList.contains('decided')) return;

                const top = m.querySelector('[data-slot="top"]');
                const bottom = m.querySelector('[data-slot="bottom"]');
                
                if (top.textContent === "è½®ç©º" && bottom.textContent !== "è½®ç©º") {
                    bottom.click();
                    // è½®ç©ºè‡ªåŠ¨æ™‹çº§æ—¶ï¼Œéšè—åˆ†æ•°è¾“å…¥æ¡†ï¼Œä»¥å…çœ‹ç€ä¹±
                    const inputs = m.querySelector('.score-inputs');
                    if(inputs) inputs.style.visibility = 'hidden';
                } else if (bottom.textContent === "è½®ç©º" && top.textContent !== "è½®ç©º") {
                    top.click();
                    const inputs = m.querySelector('.score-inputs');
                    if(inputs) inputs.style.visibility = 'hidden';
                }
            });
        }, 100);
    }

    function updateStandings() {
    // 1. å®šä¹‰ä¸€ä¸ªâ€œæ¸…æ´—åå­—â€çš„å°å·¥å…·
    const cleanName = (name) => {
        if (!name) return "";
        return name
            .replace(/[ğŸ¥‡ğŸ¥ˆğŸ¥‰]/g, '')       // åˆ æ‰å¥–ç‰Œå›¾æ ‡
            .replace(/[\(ï¼ˆ]\d+[\)ï¼‰]/g, '') // åˆ æ‰ç§å­åºå·ï¼Œå¦‚ (1) æˆ– ï¼ˆ1ï¼‰
            .trim();                        // åˆ æ‰å‰åå¤šä½™çš„ç©ºæ ¼
    };

    const list = {};
    
    // 2. ä¿®æ”¹è·å–æ¯”èµ›ç»“æœçš„é€»è¾‘ï¼ŒåŠ å…¥æ¸…æ´—æ­¥éª¤
    const getRes = (selector) => {
        const m = ui.results.querySelector(selector);
        if(m && m.classList.contains('decided')) {
            return { 
                w: cleanName(m.querySelector('.winner').textContent), 
                l: cleanName(m.querySelector('.loser').textContent) 
            };
        }
        return null;
    };

    const rounds = ui.results.querySelectorAll('.bracket .round');
    
    // 3. å¤„ç†å† äºšå†› (æ‰‹åŠ¨è·å–)
    if(rounds.length > 0) {
        const finalM = rounds[rounds.length-1].querySelector('.match');
        if(finalM && finalM.classList.contains('decided')) {
            // è¿™é‡Œä¹Ÿè¦ç”¨ cleanName åŒ…è£¹ä¸€ä¸‹
            list['ğŸ¥‡ å† å†›'] = cleanName(finalM.querySelector('.winner').textContent);
            list['ğŸ¥ˆ äºšå†›'] = cleanName(finalM.querySelector('.loser').textContent);
        }
    }
    
    // 4. å¤„ç†å­£å†›åŠå…¶ä»–åæ¬¡ (ä½¿ç”¨ getRes)
    const r34 = getRes('[data-type="bronze"]');
    if(r34) { list['ğŸ¥‰ å­£å†›'] = r34.w; list['ç¬¬å››å'] = r34.l; }
    
    const r56 = getRes('[data-type="56_final"]');
    if(r56) { list['ç¬¬äº”å'] = r56.w; list['ç¬¬å…­å'] = r56.l; }
    
    const r78 = getRes('[data-type="78_final"]');
    if(r78) { list['ç¬¬ä¸ƒå'] = r78.w; list['ç¬¬å…«å'] = r78.l; }

    // 5. æ¸²æŸ“åˆ—è¡¨
    const ul = ui.results.querySelector('.standings-list');
    const cont = document.getElementById('final-standings-container');
    if(ul && cont) {
        ul.innerHTML = '';
        const keys = Object.keys(list);
        if(keys.length > 0) {
            cont.style.display = 'block';
            keys.forEach(k => { ul.innerHTML += `<li><strong>${k}</strong><span>${list[k]}</span></li>`; });
        } else {
            cont.style.display = 'none';
        }
    }
}

function renderGroupStage(players, title, isMixed) {
    const type = isMixed ? 'mixed' : 'round-robin';
    let seeds = [];
    let others = [];
    players.forEach(p => {
        if (/[\(ï¼ˆ]\d+[\)ï¼‰]/.test(p)) {
            seeds.push(p);
        } else {
            others.push(p);
        }
    });
    seeds.sort(() => 0.5 - Math.random());
    others.sort(() => 0.5 - Math.random());

    const groups = [];
    const count = players.length;

    if (type === 'round-robin') {
        let all = [...seeds, ...others];
        all.sort(() => 0.5 - Math.random());
        groups.push(all);
    } else {
        let numGroups = 1; 
        if (count >= 4) {
            while ((numGroups * 2) * 3 <= count) numGroups *= 2;
            if (numGroups === 1 && count >= 4) numGroups = 2;
        }
        for (let i = 0; i < numGroups; i++) groups.push([]);
        let currentGroupIndex = 0;
        seeds.forEach(p => {
            groups[currentGroupIndex].push(p);
            currentGroupIndex = (currentGroupIndex + 1) % numGroups;
        });
        others.forEach(p => {
            groups[currentGroupIndex].push(p);
            currentGroupIndex = (currentGroupIndex + 1) % numGroups;
        });

        groups.forEach(group => {
            group.sort(() => 0.5 - Math.random());
        });
    }

        let html = `<div class="container"><h2 class="result-title">${title} - ${type === 'round-robin' ? 'å¾ªç¯èµ›ç§¯åˆ†è¡¨' : 'å°ç»„èµ›é˜¶æ®µ'}</h2></div>`;
        
        groups.forEach((group, index) => {
            const isSingleGroup = groups.length === 1;
            const groupName = isSingleGroup ? "æ¯”èµ›è¯¦æƒ…" : `ç¬¬ ${String.fromCharCode(65 + index)} ç»„`;
            
            let groupHtml = `<div class="group-container container" data-group-index="${index}">`;
            let subtitle = `<h3>${groupName} - ç§¯åˆ†è¡¨</h3>`;
            if (isMixed && !isSingleGroup) subtitle = `<h3>${groupName} - ç§¯åˆ†è¡¨ <span style="font-size:0.6em; color:#666; font-weight:normal;">(å‰ 2 åæ™‹çº§)</span></h3>`;
            
            groupHtml += subtitle;
            
            const headerCols = group.map((p, i) => `<th>${i+1}. ${p}</th>`).join('');
            const bodyRows = group.map((player, rIdx) => {
                const cells = group.map((_, cIdx) => rIdx === cIdx ? '<td class="diagonal"></td>' : '<td contenteditable="true"></td>').join('');
                return `<tr><th class="player-header">${rIdx+1}. ${player}</th>${cells}<td contenteditable="true"></td><td contenteditable="true"></td><td contenteditable="true"></td></tr>`;
            }).join('');
            
            groupHtml += `<table class="data-table crosstable"><thead><tr><th>${isSingleGroup?'':String.fromCharCode(65+index)}</th>${headerCols}<th>ç§¯åˆ†</th><th>å‡€èƒœ</th><th>åæ¬¡</th></tr></thead><tbody>${bodyRows}</tbody></table>`;
            
            if (isMixed) {
                let options = `<option value="">--è¯·é€‰æ‹©--</option>` + group.map(p => `<option value="${p}">${p}</option>`).join('');
                groupHtml += `
                <div class="qualification-box" style="background:#f0f9eb; padding:15px; margin-top:15px; border-radius:4px; border:1px solid #e1f3d8;">
                    <div style="font-weight:bold; color:#67c23a; margin-bottom:10px;">ğŸ† ${groupName} å‡ºçº¿åå•ç¡®è®¤</div>
                    <div style="display:flex; gap:20px;">
                        <div style="flex:1;"><label>ç¬¬ä¸€å (æ™‹çº§)</label><select class="rank-select rank-1">${options}</select></div>
                        <div style="flex:1;"><label>ç¬¬äºŒå (æ™‹çº§)</label><select class="rank-select rank-2">${options}</select></div>
                    </div>
                </div>`;
            }

            groupHtml += `<h3 style="margin-top: 30px;">${isSingleGroup ? 'å¯¹é˜µæ—¥ç¨‹' : groupName + ' - å¯¹é˜µæ—¥ç¨‹'}</h3>`;
            
            let gp = [...group];
            if (gp.length % 2 !== 0) gp.push('è½®ç©º');
            const numRounds = gp.length - 1;
            let schedule = Array.from({length: numRounds}, () => []);
            for (let r = 0; r < numRounds; r++) {
                for (let i=0; i<gp.length/2; i++) {
                    const p1 = gp[i], p2 = gp[gp.length-1-i];
                    if(p1 !== 'è½®ç©º' && p2 !== 'è½®ç©º') schedule[r].push(`${p1} VS ${p2}`);
                }
                gp.splice(1, 0, gp.pop());
            }
            const maxMatches = Math.max(0, ...schedule.map(r => r.length));
            
            let schedHtml = `<table class="data-table schedule-table"><thead><tr><th colspan="${numRounds}">å¯¹é˜µæ—¥ç¨‹è¡¨</th></tr><tr>${Array.from({length: numRounds}, (_, i) => `<th>ç¬¬ ${i+1} è½®</th>`).join('')}</tr></thead><tbody>`;
            for (let i=0; i<maxMatches; i++) {
                schedHtml += `<tr>`;
                for(let r=0; r<numRounds; r++) { schedHtml += `<td>${schedule[r][i] || ''}</td>`; }
                schedHtml += `</tr>`;
            }
            schedHtml += '</tbody></table>';
            groupHtml += schedHtml + `</div>`;
            html += groupHtml;
        });

        if(isMixed) {
             html += `<div id="advance-controls" class="container" style="text-align:center; padding:40px; margin-top:20px;">
                <p style="color:#666; margin-bottom:15px;">è¯·å…ˆåœ¨ä¸Šæ–¹å„ä¸ªå°ç»„ç¡®è®¤å‡ºçº¿åå•ï¼Œç„¶åç‚¹å‡»ä¸‹æ–¹æŒ‰é’®</p>
                <button id="advance-btn" class="main-button" style="font-size:16px; padding:15px 40px;">âœ… ç”Ÿæˆæ·˜æ±°èµ›å¯¹é˜µ (è‡ªåŠ¨äº¤å‰)</button>
             </div>`;
        }

        allTournaments[activeId].html = html;
        ui.results.innerHTML = html;

        if(isMixed) {
            document.getElementById('advance-btn').onclick = advanceMixedToKnockout;
        }
    }

    function advanceMixedToKnockout() {
        if (document.getElementById('knockout-stage-wrapper')) {
            if (!confirm("æ£€æµ‹åˆ°æ·˜æ±°èµ›å¯¹é˜µå·²å­˜åœ¨ï¼Œæ˜¯å¦é‡æ–°ç”Ÿæˆï¼Ÿ\n(æ³¨æ„ï¼šä¹‹å‰çš„æ·˜æ±°èµ›è¿›åº¦å°†ä¸¢å¤±)")) return;
            document.getElementById('knockout-stage-wrapper').remove();
        }

        const containers = document.querySelectorAll('.group-container');
        let qualifiers = [];
        let isValid = true;

        containers.forEach((div, i) => {
            const r1 = div.querySelector('.rank-1').value;
            const r2 = div.querySelector('.rank-2').value;
            
            if (!r1 || !r2) {
                alert(`è¯·å®Œæ•´é€‰æ‹©â€œç¬¬ ${String.fromCharCode(65 + i)} ç»„â€çš„ç¬¬ä¸€åå’Œç¬¬äºŒåï¼`);
                isValid = false;
                return;
            }
            if (r1 === r2) {
                alert(`â€œç¬¬ ${String.fromCharCode(65 + i)} ç»„â€çš„ç¬¬ä¸€åå’Œç¬¬äºŒåä¸èƒ½æ˜¯åŒä¸€ä¸ªäººï¼`);
                isValid = false;
                return;
            }
            qualifiers.push({ group: i, rank: 1, name: r1 });
            qualifiers.push({ group: i, rank: 2, name: r2 });
        });

        if (!isValid) return;

        let bracketList = [];
        const numGroups = containers.length;

        for (let i = 0; i < numGroups; i += 2) {
            const g1 = i; 
            const g2 = i + 1; 

            if (g2 < numGroups) {
                const a1 = qualifiers.find(q => q.group === g1 && q.rank === 1).name;
                const a2 = qualifiers.find(q => q.group === g1 && q.rank === 2).name;
                const b1 = qualifiers.find(q => q.group === g2 && q.rank === 1).name;
                const b2 = qualifiers.find(q => q.group === g2 && q.rank === 2).name;
                bracketList.push(a1, b2); 
                bracketList.push(b1, a2);
            } else {
                const c1 = qualifiers.find(q => q.group === g1 && q.rank === 1).name;
                const c2 = qualifiers.find(q => q.group === g1 && q.rank === 2).name;
                bracketList.push(c1, c2);
            }
        }

        const bracketHTML = getBracketHTML(bracketList, "ç¬¬äºŒé˜¶æ®µï¼šæ·˜æ±°èµ›");
        
        const wrapper = document.createElement('div');
        wrapper.id = "knockout-stage-wrapper";
        wrapper.innerHTML = bracketHTML;

        const btnContainer = document.getElementById('advance-controls');
        if(btnContainer) btnContainer.style.display = 'none';

        ui.results.appendChild(wrapper);
        wrapper.scrollIntoView({ behavior: 'smooth' });

        saveData(false);

        setTimeout(() => {
            drawConnectors();
            autoAdvanceByes();
        }, 100);
    }

    function saveData(alertUser = true) {
        if (activeId && ui.results.style.display !== 'none') {
            allTournaments[activeId].html = ui.results.innerHTML;
        }
        localStorage.setItem('my_tournament_data_v13', JSON.stringify(allTournaments));
        if (alertUser) alert("å·²ä¿å­˜");
    }

    function editCurrent() {
        const t = allTournaments[activeId];
        renderNameInputs(t.count);
        const inputs = ui.manualInputs.querySelectorAll('input');
        t.players.forEach((p, i) => { if(inputs[i]) inputs[i].value = p; });
        hideAll();
        ui.names.style.display = 'block';
    }

    function exportJson() {
        const blob = new Blob([JSON.stringify(allTournaments)], {type: "application/json"});
        const link = document.createElement("a");
        link.href = URL.createObjectURL(blob);
        link.download = `æ¯”èµ›å¤‡ä»½_${new Date().toLocaleDateString()}.json`;
        link.click();
    }

    function importJson(e) {
        const file = e.target.files[0];
        if(!file) return;
        const reader = new FileReader();
        reader.onload = (ev) => {
            try {
                allTournaments = JSON.parse(ev.target.result);
                localStorage.setItem('my_tournament_data_v13', JSON.stringify(allTournaments));
                alert("å¯¼å…¥æˆåŠŸ");
                location.reload();
            } catch(err) { alert("æ–‡ä»¶æ ¼å¼é”™è¯¯"); }
        };
        reader.readAsText(file);
    }

    init();
});
</script>
</body>
</html>
